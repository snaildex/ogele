#version 430

layout( local_size_x = 1 ) in;

struct Triangle {
	vec4 Position[3];
	vec4 Normal[3];
	vec4 TriNormal;
	vec4 NormDot;
	vec4 Domain;
	vec4 Spheres[6];
};

layout(std430, binding = 0) buffer PosBuffer { vec4 Pos[]; };
layout(std430, binding = 1) buffer NormBuffer { vec4 Norm[]; };
layout(std430, binding = 2) buffer IndexBuffer { uvec4 Index[]; };
layout(std430, binding = 3) buffer TrisBuffer { Triangle Tris[]; };

uint GetIndex(uint i) { return Index[i/4][i%4]; }

vec4 CalculateSphere(vec3 a, vec3 b, vec3 n) {
	//return vec4(a-n*0.3,0.3);
	vec3 d = (b-a) / 2;
	float r = length(d) / dot(-n, normalize(d));
	return vec4(a-n*r,r);
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;
	Triangle tri;
	for(int i=0; i<3; ++i) {
		tri.Position[i] = Pos[GetIndex(idx * 3 + i)];
		tri.Normal[i] = normalize(Norm[GetIndex(idx * 3 + i)]);
	}
	tri.TriNormal.xyz = normalize(cross(tri.Position[1].xyz-tri.Position[0].xyz,tri.Position[2].xyz-tri.Position[0].xyz));
	//for(int i=0; i<3; ++i) tri.Normal[i] = tri.TriNormal;
	tri.NormDot.xyz = vec3(dot(tri.TriNormal.xyz,tri.Normal[0].xyz), dot(tri.TriNormal.xyz,tri.Normal[1].xyz), dot(tri.TriNormal.xyz,tri.Normal[2].xyz));

	float a=distance(tri.Position[1].xyz, tri.Position[2].xyz);
	float b=distance(tri.Position[0].xyz, tri.Position[2].xyz);
	float c=distance(tri.Position[0].xyz, tri.Position[1].xyz);
	vec3 bc;
	bc.x=a*a*(b*b+c*c-a*a);
	bc.y=b*b*(a*a+c*c-b*b);
	bc.z=c*c*(b*b+a*a-c*c);
	float sum=bc.x+bc.y+bc.z;
	bc/=sum;
	tri.Domain.xyz=tri.Position[0].xyz*bc.x+tri.Position[1].xyz*bc.y+tri.Position[2].xyz*bc.z;
	tri.Domain.w=distance(tri.Domain.xyz,tri.Position[0].xyz);
	tri.Spheres[0]=CalculateSphere(tri.Position[0].xyz,tri.Position[1].xyz,tri.Normal[0].xyz);
	tri.Spheres[1]=CalculateSphere(tri.Position[0].xyz,tri.Position[2].xyz,tri.Normal[0].xyz);
	tri.Spheres[2]=CalculateSphere(tri.Position[1].xyz,tri.Position[0].xyz,tri.Normal[1].xyz);
	tri.Spheres[3]=CalculateSphere(tri.Position[1].xyz,tri.Position[2].xyz,tri.Normal[1].xyz);
	tri.Spheres[4]=CalculateSphere(tri.Position[2].xyz,tri.Position[0].xyz,tri.Normal[2].xyz);
	tri.Spheres[5]=CalculateSphere(tri.Position[2].xyz,tri.Position[1].xyz,tri.Normal[2].xyz);
	Tris[idx] = tri;
}